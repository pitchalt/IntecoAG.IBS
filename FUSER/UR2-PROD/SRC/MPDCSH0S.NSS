* >Natural Source Header 000000 /*<RO>>
* :NatName MPDCSH0S
* :UID ARMK01
* :Mode S
* :CP
* :Date 20070703
* :Time 1927000
* <Natural Source Header /*<<RO>
/***********************************************************************
/*
/* —»—“≈Ã¿: ARM-K
/* œ–Œ√–¿ÃÃ¿: œŒ»—  ¬ —œ–¿¬Œ◊Õ» ≈
/*
/* –¿«–¿¡Œ“◊» :
/* ƒ¿“¿ ¬€œ”— ¿:
/*
/* Õ¿«¬¿Õ»≈: œŒ»—  ƒŒ ”Ã≈Õ“Œ¬ ƒÀﬂ –≈ƒ¿ “»–Œ¬¿Õ»ﬂ
/*  ŒÃ¿Õƒ€:
/*  - SELECT
/*
/* »—œ–¿¬À≈Õ»ﬂ:
/*
/***********************************************************************
DEFINE DATA
PARAMETER USING XXERX00A
PARAMETER USING XXCTXX0A
PARAMETER USING XMBMXX1A
PARAMETER USING MPDCSH0A
/*
LOCAL USING XXXXEC0L
/*
LOCAL USING UDDRMN0L
LOCAL USING UBDRMN0A
LOCAL USING UXCSXX0A
LOCAL USING XBDRSX0L
LOCAL USING MPDCSC0L
LOCAL USING MPDCSR0L
LOCAL USING XPMOSH0A
LOCAL USING MBVOMN0A
LOCAL USING MBMOMN0A
LOCAL USING MBZKMN0A
LOCAL USING UBODMN0A
LOCAL USING STEKL
/*LOCAL USING ASUM-IZ
LOCAL
1 #ERROR      (I4)
1 #RETAIN     (A8)
1 #NUMBER     (P10)
1 #COUNT      (I4)
1 #POS        (I4)
1 #FLAG       (L)
1 #POSITION   (I4)
1 #CMD        (A8)
/*
1 CNTST       (I4) INIT  <200>
/*
1 STACKDC-LEN (I4) CONST <100>
1 STACKDC-LENB(B4)
1 STACKDC-A   (A1/1:STACKDC-LEN)
1 REDEFINE STACKDC-A
2 STACKDC-G
3 DC-ID        (P15)
3 OD-ID        (P7)
3 DD-ID        (P7)
3 DC-NUMBER    (A6)
3 DC-DATE      (D)
3 MO-ID        (P15)
3 KOR-MO-ID    (P15)
3 KOR-VO-ID    (P15)
3 KOR-ZK-ID    (P15)
/*
/*1 C-Z         (C/7)
END-DEFINE
DEFINE SUBROUTINE MPDCSH0S
/*
DEFINE WINDOW WINDOW-RESULT
  SIZE 20*80
  BASE 5/1
  TITLE '—ÔËÒÓÍ ‰ÓÍÛÏÂÌÚÓ‚'
  FRAMED ON
/*
DEFINE WINDOW WINDOW-CRITERY
  SIZE 18*80
  BASE 7/1
  TITLE 'œ‡‡ÏÂÚ˚ ÔÓËÒÍ‡ ‰ÓÍÛÏÂÌÚÓ‚'
  FRAMED ON
/*
SET KEY ALL
SET CONTROL 'MT'
MOVE RETURN-CODE TO #ERROR
RESET XXERX00A BO-COMMAND-PROCESS BM-OBJECT
MOVE #ERROR TO RETURN-CODE
#RETAIN := *PROGRAM
MOVE STACKDC-LEN TO STACKDC-LENB
/*
DECIDE ON FIRST VALUE BM-COMMAND
  VALUE 'SELECT'
     #CMD := "CRITERY"
     PERFORM DC-SELECT
     IF #CMD EQ "SELECT" THEN
        MOVE STACKDC-A.DC-ID TO MPDCSH0A.DR-ID
        MOVE STACKDC-A.OD-ID TO MPDCSH0A.OD-ID
        MOVE MPDCSH0A.DR-ID TO BM-OBJECT
        MOVE "SELECT" TO BO-COMMAND-PROCESS
     ELSE
        MOVE "EXIT" TO BO-COMMAND-PROCESS
     END-IF
  NONE VALUE
     *ERROR-NR := EC-UNKNOW-COMMAND
END-DECIDE
/*
SET WINDOW OFF
/*
DEFINE SUBROUTINE DC-SELECT
  REPEAT
     DECIDE ON FIRST VALUE #CMD
     VALUE "CRITERY"
        PERFORM DC-CRITERY
     VALUE "SHOW"
        PERFORM DC-SHOW
     VALUE "SELECT"
        ESCAPE BOTTOM
     VALUE "EXIT"
        MOVE "EXIT" TO BO-COMMAND-PROCESS
        ESCAPE BOTTOM
     NONE VALUE
        *ERROR-NR := EC-UNKNOW-COMMAND
     END-DECIDE
  END-REPEAT
END-SUBROUTINE
/*
DEFINE SUBROUTINE DC-CRITERY
  IF XXCTXX0A.US-MO-ID NE 0 THEN
     MOVE XXCTXX0A.US-MO-ID TO MBMOMN0A.MO-ID
     MOVE "READ" TO MBMOMN0A.BL-COMMAND
     PERFORM MBMOMN0S XXERX00A XXCTXX0A MBMOMN0A
     IF RETURN-CODE NE 0 THEN *ERROR-NR := EC-QUIT-STACK-TRACE END-IF
     MOVE BY NAME MBMOMN0A TO MPDCSC0L
     MOVE MBMOMN0A.MO-CODE TO MPDCSC0L.MO-SEARCH
/*     MOVE (AD=P) TO MPDCSC0L.MO-C
  END-IF
  RESET #CMD
  IF DC-DATE-START EQ 0 THEN
     MOVE EDITED *DATX (EM=YYYYMMDD) TO DC-DATE-START-A
     MOVE 01 TO DC-DATE-START-DD
     MOVE DC-DATE-START TO DC-DATE-STOP
/*   SUBTRACT 1 FROM DC-DATE-START-MM
/*   IF DC-DATE-START-MM LT 1 THEN
/*      DC-DATE-START-MM := 12
/*      SUBTRACT 1 FROM DC-DATE-START-YYYY
/*   END-IF
     ADD 1 TO DC-DATE-STOP-MM
     IF DC-DATE-STOP-MM GT 12 THEN
        DC-DATE-STOP-MM := 1
        ADD 1 TO DC-DATE-STOP-YYYY
     END-IF
  END-IF
  SET WINDOW 'WINDOW-CRITERY'
  SET KEY NAMED OFF
  SET KEY ENTR NAMED '»ÒÍ‡Ú'
  SET KEY PF3 NAMED '¬˚ıÓ‰'
  SET KEY PF11 NAMED '¬˚·Ó'
  REPEAT
     IF RETURN-CODE EQ -1 THEN
        PERFORM XPERVW0S XXERX00A
        RESET RETURN-CODE
     END-IF
     IF RETURN-CODE NE 0 THEN
        INPUT WINDOW='WINDOW-CRITERY' WITH TEXT *RETURN-CODE
              USING MAP "MPDCSC0M"
        RESET RETURN-CODE
     ELSE
        INPUT WINDOW='WINDOW-CRITERY' USING MAP "MPDCSC0M"
     END-IF
     IF *PF-KEY EQ "PF3" THEN
        #CMD := "EXIT"
        ESCAPE BOTTOM
     END-IF
     IF *PF-KEY EQ "PF11" THEN
        IF XXCTXX0A.US-MO-ID EQ 0 THEN
           MOVE BY NAME MPDCSC0L TO XPMOSH0A
           MOVE "SELECT" TO XPMOSH0A.SH-COMMAND
           PERFORM XPMOSH0S XXERX00A XXCTXX0A XPMOSH0A
           IF RETURN-CODE NE 0 THEN ESCAPE TOP END-IF
           IF XPMOSH0A.MO-ID NE 0 THEN
              MOVE BY NAME XPMOSH0A TO MPDCSC0L
              MOVE XPMOSH0A.MO-CODE TO MPDCSC0L.MO-SEARCH
           END-IF
        END-IF
        ESCAPE TOP
     END-IF
     IF DC-DATE-STOP < DC-DATE-START THEN
        DC-DATE-STOP := DC-DATE-START
     END-IF
     IF DC-DATE-START < 19900000 OR DC-DATE-START-A NE MASK (YYYYMMDD) THEN
        REINPUT *2302 MARK *DC-DATE-START
     END-IF
     IF DC-DATE-STOP NE 0 THEN
        IF DC-DATE-STOP < 19900000 OR DC-DATE-STOP-A NE MASK (YYYYMMDD) THEN
           REINPUT *2302 MARK *DC-DATE-STOP
        END-IF
     END-IF
     IF MPDCSC0L.MO-SEARCH NE ' ' AND MO-C MODIFIED THEN
        IF XXCTXX0A.US-MO-ID EQ 0 THEN
           MOVE BY NAME MPDCSC0L TO XPMOSH0A
           MOVE "LOCATE" TO XPMOSH0A.SH-COMMAND
           PERFORM XPMOSH0S XXERX00A XXCTXX0A XPMOSH0A
           IF RETURN-CODE NE 0 THEN ESCAPE TOP END-IF
           IF XPMOSH0A.MO-ID NE 0 THEN
              MOVE BY NAME XPMOSH0A TO MPDCSC0L
              MOVE XPMOSH0A.MO-CODE TO MPDCSC0L.MO-SEARCH
           END-IF
        END-IF
     END-IF
     IF MPDCSC0L.MO-SEARCH EQ ' ' THEN
        RESET MPDCSC0L.MO-ID MPDCSC0L.MO-CODE MPDCSC0L.MO-NAME
     END-IF
     IF *PF-KEY EQ "ENTR"
        PERFORM DC-SEARCH
        IF #COUNT EQ 0 THEN RETURN-CODE := 2408  ESCAPE TOP END-IF
        #CMD := "SHOW"
        ESCAPE ROUTINE
     END-IF
  END-REPEAT
END-SUBROUTINE
/*
DEFINE SUBROUTINE DC-SHOW
  SET WINDOW 'WINDOW-RESULT'
  SET KEY NAMED OFF
  SET KEY ENTR NAMED '¬˚·Ú'
  SET KEY PF3 NAMED  '¬˚ıÓ‰'
  SET KEY PF7 NAMED  'Õ‡Á‡‰'
  SET KEY PF8 NAMED  '¬ÔÂ‰'
  SET KEY PF6 NAMED  'œ‡‡Ï'
  MOVE 1 TO #N
  RESET #CMD
  REPEAT
     PERFORM DC-LIST
     INPUT USING MAP "MPDCSR0M"
     IF *PF-KEY EQ 'PF6' THEN
        #CMD := "CRITERY"
        ESCAPE BOTTOM
     END-IF
     IF *PF-KEY EQ 'PF3' THEN
        #CMD := "EXIT"
        ESCAPE BOTTOM
     END-IF
     IF *PF-KEY EQ 'PF7' AND #N > 7
        ADD -7 TO #N
     END-IF
     IF *PF-KEY EQ 'PF8' AND #K < #COUNT
        ADD 7 TO #N
     END-IF
     IF *PF-KEY EQ 'ENTR' THEN
        FOR #I = 1 TO 7
           IF *CURS-FIELD EQ POS(CP-CMD(#I)) THEN
              XI := STACK-REC-ID(#I)
              CALL 'RWSX' XI STACKDC-A(1) XR XN1
              #CMD := "SELECT"
              ESCAPE ROUTINE
           END-IF
        END-FOR
     END-IF
  END-REPEAT
END-SUBROUTINE
/*
DEFINE SUBROUTINE DC-LIST
  RESET MPDCSR0L.DC-LIST(*)
  #K := #N + 6  #L := 0  CP-CMD-C(*) := (AD=PN)
  FOR #I #N #K
/*     WRITE #N #I #L
    IF #I <= #COUNT  XI := #I  CALL 'RWSX' XI STACKDC-A(1) XR XN1
/*      #SELECTED := STEKEI.EI-CODE
      ADD 1 TO #L  RESET CP-CMD-C(#L)
      MOVE BY NAME STACKDC-G TO MPDCSR0L.DC-LIST(#L)
     /*
      MOVE STACKDC-A.MO-ID TO MBMOMN0A.MO-ID
      MOVE "READ" TO MBMOMN0A.BL-COMMAND
      PERFORM MBMOMN0S XXERX00A XXCTXX0A MBMOMN0A
      IF RETURN-CODE NE 0 THEN *ERROR-NR := EC-QUIT-STACK-TRACE END-IF
      MOVE BY NAME MBMOMN0A TO MPDCSR0L.DC-LIST(#L)
      /*
      MOVE STACKDC-A.OD-ID TO UBODMN0A.OD-ID
      MOVE "READ" TO UBODMN0A.BL-COMMAND
      PERFORM UBODMN0S XXERX00A XXCTXX0A UBODMN0A UXCSXX0A
      IF RETURN-CODE NE 0 THEN *ERROR-NR := EC-QUIT-STACK-TRACE END-IF
      COMPRESS UBODMN0A.OD-CODE UBODMN0A.OD-NAME INTO UBODMN0A.OD-NAME
      MOVE BY NAME UBODMN0A TO MPDCSR0L.DC-LIST(#L)
     /*
      IF STACKDC-A.KOR-MO-ID NE 0 THEN
        MOVE STACKDC-A.KOR-MO-ID TO MBMOMN0A.MO-ID
        MOVE "READ" TO MBMOMN0A.BL-COMMAND
        PERFORM MBMOMN0S XXERX00A XXCTXX0A MBMOMN0A
        IF RETURN-CODE NE 0 THEN *ERROR-NR := EC-QUIT-STACK-TRACE END-IF
        COMPRESS '(' MBMOMN0A.MO-CODE ')' MBMOMN0A.MO-NAME
              INTO MPDCSR0L.OB-DESC(#L)
      END-IF
     /*
      IF STACKDC-A.KOR-VO-ID NE 0 THEN
        MOVE STACKDC-A.KOR-VO-ID TO MBVOMN0A.VO-ID
        MOVE "READ" TO MBVOMN0A.BL-COMMAND
        PERFORM MBVOMN0S XXERX00A XXCTXX0A MBVOMN0A
        IF RETURN-CODE NE 0 THEN *ERROR-NR := EC-QUIT-STACK-TRACE END-IF
        COMPRESS '(' MBVOMN0A.VO-CODE ')' MBVOMN0A.VO-INN MBVOMN0A.VO-NAME
              MBVOMN0A.VO-ADDRESS INTO MPDCSR0L.OB-DESC(#L)
      END-IF
      MOVE XI TO STACK-REC-ID(#L)
    END-IF
  END-FOR
END-SUBROUTINE
/*
DEFINE SUBROUTINE DC-SEARCH
  XI := CNTST  CALL 'GTSX' STACKDC-LENB XI XN1
  #N := XW := 1
  RESET #COUNT
  IF DC-DATE-STOP EQ 0 THEN
     DC-DATE-STOP := DC-DATE-START
  END-IF
  MOVE MPDCSH0A.DD-ID TO DR-AP-SUPER-G.DR-TYPE-ID(*)
  MOVE TRUE TO DR-AP-SUPER-G.DR-AP-IS-INDEX(*)
  MOVE MPDCSH0A.DC-DATE-ATTR-ID TO DR-AP-SUPER-G.DR-AP-ATTR-ID(1)
  MOVE MPDCSC0L.DC-DATE-START TO DR-AP-SUPER-G.DR-AP-VALUE(1)
  MOVE MPDCSH0A.DC-DATE-ATTR-ID TO DR-AP-SUPER-G.DR-AP-ATTR-ID(2)
  MOVE MPDCSC0L.DC-DATE-STOP TO DR-AP-SUPER-G.DR-AP-VALUE(2)
  MOVE MPDCSH0A.DC-MO-ATTR-ID TO DR-AP-SUPER-G.DR-AP-ATTR-ID(3)
  MOVE MPDCSC0L.MO-ID TO DR-AP-SUPER-G.DR-AP-VALUE(3)
  MOVE MPDCSH0A.DC-KOR-MO-ATTR-ID TO DR-AP-SUPER-G.DR-AP-ATTR-ID(4)
  MOVE MPDCSC0L.MO-ID TO DR-AP-SUPER-G.DR-AP-VALUE(4)
/*
  MOVE MPDCSH0A.DD-ID TO DR-AS-SUPER-G.DR-TYPE-ID(*)
  MOVE TRUE TO DR-AS-SUPER-G.DR-AS-IS-INDEX(*)
  MOVE MPDCSH0A.DC-NUMBER-ATTR-ID TO DR-AS-SUPER-G.DR-AS-ATTR-ID(1)
  MOVE MPDCSC0L.DC-NUMBER TO DR-AS-SUPER-G.DR-AS-VALUE(1)
  DECIDE FOR FIRST CONDITION
     WHEN MPDCSC0L.DC-NUMBER NE " " AND MPDCSC0L.MO-ID NE 0

FL1.
        FIND NUMBER UR-DOC-DATA-VIEW WITH
                    DR-AS-SUPER EQ DR-AS-SUPER(1) AND
                    DR-AP-SUPER EQ DR-AP-SUPER(1) THRU DR-AP-SUPER(2) AND
                    (DR-AP-SUPER EQ DR-AP-SUPER(3) OR
                     DR-AP-SUPER EQ DR-AP-SUPER(4))
                 RETAIN AS #RETAIN
        MOVE *NUMBER(FL1.) TO #NUMBER
     WHEN MPDCSC0L.DC-NUMBER NE " "
FL2.
        FIND NUMBER UR-DOC-DATA-VIEW WITH
                    DR-AS-SUPER EQ DR-AS-SUPER(1) AND
                    DR-AP-SUPER EQ DR-AP-SUPER(1) THRU DR-AP-SUPER(2)
                 RETAIN AS #RETAIN
        MOVE *NUMBER(FL2.) TO #NUMBER
     WHEN MPDCSC0L.MO-ID NE 0
FL3.
        FIND NUMBER UR-DOC-DATA-VIEW WITH
                    DR-AP-SUPER EQ DR-AP-SUPER(1) THRU DR-AP-SUPER(2) AND
                    (DR-AP-SUPER EQ DR-AP-SUPER(3) OR
                     DR-AP-SUPER EQ DR-AP-SUPER(4))
                 RETAIN AS #RETAIN
        MOVE *NUMBER(FL3.) TO #NUMBER
     WHEN NONE
FL4.
        FIND NUMBER UR-DOC-DATA-VIEW WITH
                    DR-AP-SUPER EQ DR-AP-SUPER(1) THRU DR-AP-SUPER(2)
                 RETAIN AS #RETAIN
        MOVE *NUMBER(FL4.) TO #NUMBER
  END-DECIDE
  IF #NUMBER = 0 THEN ESCAPE ROUTINE END-IF
  FOR #I = 1 TO 10
    IF MPDCSH0A.DR-ATTR-ID(#I) EQ 0 THEN ESCAPE BOTTOM END-IF
    MOVE MPDCSH0A.DR-ATTR-ID(#I) TO DR-AP-SUPER-G.DR-AP-ATTR-ID(1)
    MOVE MPDCSH0A.DR-VALUE(#I) TO DR-AP-SUPER-G.DR-AP-VALUE(1)
FL5.
    FIND NUMBER UR-DOC-DATA-VIEW WITH #RETAIN AND
                                DR-AP-SUPER EQ DR-AP-SUPER(1)
           RETAIN AS #RETAIN
    IF *NUMBER(FL5.) EQ 0 THEN ESCAPE ROUTINE END-IF
  END-FOR
  FIND UR-DOC-DATA-VIEW WITH #RETAIN
     ACCEPT DR-TX-CURRENT-ID EQ 0
     PERFORM DC2STACK
  END-FIND
  RELEASE SET #RETAIN
END-SUBROUTINE
/*
DEFINE SUBROUTINE DC2STACK
  IF UR-DOC-DATA-VIEW.DR-TX-STATUS NE "N" AND
     UR-DOC-DATA-VIEW.DR-TX-STATUS NE "D" THEN
     ESCAPE ROUTINE
  END-IF
  ADD 1 TO #COUNT
  IF #COUNT > CNTST  #K := XI := CNTST  CALL 'GTSX' STACKDC-LENB XI XN2
    FOR #I 1 CNTST  XI := #I  CALL 'RWSX' XI STACKDC-A(1) XR XN1
      CALL 'RWSX' XI STACKDC-A(1) XW XN2
    END-FOR
    CALL 'FRSX' XN1
    ADD 200 TO CNTST  XI := CNTST  CALL 'GTSX' STACKDC-LENB XI XN1
    FOR #I 1 #K  XI := #I  CALL 'RWSX' XI STACKDC-A(1) XR XN2
      CALL 'RWSX' XI STACKDC-A(1) XW XN1
    END-FOR
    CALL 'FRSX' XN2
  END-IF
  RESET STACKDC-G
  MOVE UR-DOC-DATA-VIEW.DR-ID TO STACKDC-A.DC-ID
  MOVE UR-DOC-DATA-VIEW.OD-ID TO STACKDC-A.OD-ID
  MOVE UR-DOC-DATA-VIEW.DR-TYPE-ID TO STACKDC-A.DD-ID
  MOVE BY NAME UR-DOC-DATA-VIEW TO UBDRMN0A
  MOVE UR-DOC-DATA-VIEW.C*DR-AP-G TO UBDRMN0A.DR-AP-C
  MOVE UR-DOC-DATA-VIEW.C*DR-AS-G TO UBDRMN0A.DR-AS-C
  INCLUDE XBDRSUAC "DC-NUMBER-ATTR-ID" "STACKDC-A.DC-NUMBER"
  INCLUDE XBDRSUDC "DC-DATE-ATTR-ID" "STACKDC-A.DC-DATE"
  INCLUDE XBDRSUIC "DC-MO-ATTR-ID" "STACKDC-A.MO-ID"
  INCLUDE XBDRSUIC "DC-KOR-MO-ATTR-ID" "STACKDC-A.KOR-MO-ID"
  INCLUDE XBDRSUIC "DC-KOR-VO-ATTR-ID" "STACKDC-A.KOR-VO-ID"
  INCLUDE XBDRSUIC "DC-KOR-ZK-ATTR-ID" "STACKDC-A.KOR-ZK-ID"
/*  WRITE #COUNT  STACKDC-A.DC-NUMBER STACKDC-A.DC-DATE STACKDC-A.MO-ID
  XI := #COUNT  CALL 'RWSX' XI STACKDC-A(1) XW XN1
END-SUBROUTINE
/*
INCLUDE XXERSY1C
/*
END-SUBROUTINE
END

