* >Natural Source Header 000000 /*<RO>>
* :NatName MBSASH3S
* :UID ARMK523
* :Mode S
* :CP
* :Date 20090406
* :Time 1120000
* <Natural Source Header /*<<RO>
/***********************************************************************
/*
/* СИСТЕМА:
/* ПРОГРАММА:
/*
/* РАЗРАБОТЧИК:  УЗОРИН П.А.
/* ДАТА ВЫПУСКА:
/*
/* НАЗВАНИЕ:  поиск сальдо и заполнение стека
/*
/* КОМАНДЫ:
/*   ADD
/*
/* ИСПРАВЛЕНИЯ:
/*
/***********************************************************************
DEFINE DATA
PARAMETER USING XXERX00A
PARAMETER USING XXCTXX0A
PARAMETER USING MBSASH0A
PARAMETER USING MBSAST0A
PARAMETER USING UXCSXX0A
/*
LOCAL USING XXXXEC0L
LOCAL USING UXXXEC0L
LOCAL USING MXITAT0L
LOCAL USING XXSTMN0L
LOCAL USING XBDRSX0L
LOCAL USING MBSAST0L
LOCAL USING XPPBXX0A
LOCAL USING UBITMN0A
/*
LOCAL USING UDSASH0A
LOCAL USING UDSASH0L
LOCAL
1 #DATA-A     (A8)
1 REDEFINE #DATA-A
2 #DATA-N     (N8)
/*
LOCAL
1 #I          (I4)
1 #SIGN       (P1)
1 #TYPE       (A1)
1 #COUNT      (I4)
/*
1 #CUR-FREE   (B4)
/*1 #CUR-PREV   (B4)
1 #CUR-FIRST  (L)
/*
 1 BUFFER
 2 STACK-POS (B4)
 2 STACK-POS-I (I4)
 2 STACK-TMP-B1 (B4)
 2 STACK-TMP-B2 (B4)
 2 STACK-FIELD-POS (B4)
 2 STACK-FIELD-LEN (B4)
 2 STACK-REC-B (B1/1:MBSAST0L-REC-LEN)
 2 REDEFINE STACK-REC-B
 3 STACK-REC-G
 4 SA-ID (B4)
 4 STACK-KEY-B (B1/1:MBSAST0L-KEY-LEN)
 4 REDEFINE STACK-KEY-B
 5 STACK-KEY-G
 6 IX-ID (P15)
 4 FREE-NEXT (B4)
 4 FREE-PREV (B4)
 4 IS-FREE (L)
 4 DT-ID (P15)
 4 IT-ID (P7)
 4 IT-SALDO-TYPE (P1)
 4 MO-ID (P15)
 4 DP-ID (P15)
 4 MT-ID (P15)
 4 BASE-MT-ID (P15)
 4 DF-ID (P15)
 4 GM-ID (P15)
 4 PR-ID (P15)
 4 LK-ID (P15)
 4 ZK-ID (P15)
 4 BS-ID (P15)
 4 BASE-EI-ID (P15)
 4 BASE-COL (P8.7)
 4 PRIH-EI-ID (P15)
 4 PRIH-COL (P8.7)
 4 PLAN-EI-ID (P15)
 4 PLAN-COL (P8.7)
 4 BALC-SUMMA (P13.2)
END-DEFINE
DEFINE SUBROUTINE MBSASH3S
RESET XXERX00A
/*
DECIDE ON FIRST VALUE MBSASH0A.BL-COMMAND
VALUE "SEARCH"
  /* инитим стек если стек еще не размещен
  IF STACK-COUNT EQ 0 THEN
     PERFORM STACK-INIT
  END-IF
  PERFORM RECORD-SEARCH
NONE VALUE
  MOVE MBSASH0A.BL-COMMAND TO ERROR-ADDITION(1)
  *ERROR-NR := EC-UNKNOW-COMMAND
END-DECIDE
/*
INCLUDE UDSASH0C "QUERY-PROCESS" "RECORD-PROCESS" "RECORD-PROGRESS"
/*
DEFINE SUBROUTINE RECORD-PROGRESS
  ADD 1 TO #COUNT
  INCLUDE XPPBST0C "#COUNT"
/*  WRITE UR-ACC-SALDO-VIEW.MD-IT-ID(1) UR-ACC-SALDO-VIEW.MD-IT-ID(2)
END-SUBROUTINE
/*
DEFINE SUBROUTINE RECORD-SEARCH
  IF MBSASH0A.SA-DT NE 0 THEN
     IF MBSASH0A.SA-DT-ATTR-ID EQ 0 THEN
        *ERROR-NR := EC-ATTR-REQUIRED
     END-IF
  END-IF
/* читаем определение регистра что-бы определить cl-id (по идее нужно
/* просматривать все регистры и использовать множество cl-id)
  MOVE MBSASH0A.IT-ID(1) TO UBITMN0A.IT-ID
  MOVE "READ" TO UBITMN0A.BL-COMMAND
  PERFORM UBITMN0S XXERX00A XXCTXX0A UBITMN0A UXCSXX0A
  IF RETURN-CODE NE 0 THEN *ERROR-NR := EC-QUIT-STACK-TRACE END-IF
/* готовим параметры запроса
  IF MBSASH0A.PR-ID NE 0 THEN
     ADD 1 TO SH-AT-C
     MOVE PR-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
     MOVE MBSASH0A.PR-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
/*     WRITE 'pr' UDSASH0A.SH-AT-ATTR-ID(SH-AT-C) UDSASH0A.SH-AT-VALUE(SH-AT-C)
  END-IF
/*  WRITE UBITMN0A.IT-ID MBSASH0A.MT-ID MBSASH0A.DF-ID MBSASH0A.LK-ID
/*        MBSASH0A.ZK-ID MBSASH0A.MO-ID MBSASH0A.GM-ID MBSASH0A.BS-ID
/*        MBSASH0A.KOR-DP-ID MBSASH0A.KOR-MO-ID MBSASH0A.KOR-VO-ID
/*        MBSASH0A.KOR-ZK-ID "-"
  IF MBSASH0A.MT-ID NE 0 THEN
     ADD 1 TO SH-AT-C
     MOVE MT-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
     MOVE MBSASH0A.MT-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
  END-IF
  IF MBSASH0A.BASE-MT-ID NE 0 THEN
     ADD 1 TO SH-AT-C
     MOVE MT-BASE-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
     MOVE MBSASH0A.BASE-MT-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
  END-IF
  IF MBSASH0A.DF-ID NE 0 THEN
     ADD 1 TO SH-AT-C
     MOVE DF-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
     MOVE MBSASH0A.DF-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
  END-IF
  IF MBSASH0A.LK-ID NE 0 THEN
     ADD 1 TO SH-AT-C
     MOVE LK-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
     MOVE MBSASH0A.LK-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
  END-IF
  IF MBSASH0A.ZK-ID NE 0 THEN
     ADD 1 TO SH-AT-C
     MOVE ZK-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
     MOVE MBSASH0A.ZK-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
  END-IF
  IF MBSASH0A.MO-ID NE 0 THEN
     ADD 1 TO SH-AT-C
     MOVE MO-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
     MOVE MBSASH0A.MO-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
  END-IF
  IF MBSASH0A.GM-ID NE 0 THEN
     ADD 1 TO SH-AT-C
     MOVE GM-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
     MOVE MBSASH0A.GM-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
/*     WRITE 'gm' UDSASH0A.SH-AT-ATTR-ID(SH-AT-C) UDSASH0A.SH-AT-VALUE(SH-AT-C)
  END-IF
  IF MBSASH0A.BS-ID NE 0 THEN
     ADD 1 TO SH-AT-C
     MOVE BS-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
     MOVE MBSASH0A.BS-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
  END-IF
/*  IF MBSASH0A.KOR-MO-ID NE 0 THEN
/*     ADD 1 TO SH-AT-C
/*     MOVE MO-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
/*     MOVE MBSASH0A.KOR-MO-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
/*  END-IF
/*  IF MBSASH0A.KOR-VO-ID NE 0 THEN
/*     ADD 1 TO SH-AT-C
/*     MOVE VO-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
/*     MOVE MBSASH0A.KOR-VO-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
/*  END-IF
/*  IF MBSASH0A.KOR-ZK-ID NE 0 THEN
/*     ADD 1 TO SH-AT-C
/*     MOVE ZK-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
/*     MOVE MBSASH0A.KOR-ZK-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
/*  END-IF
  MOVE MBSASH0A.IT-ID(*) TO UDSASH0A.SH-IT-ID(*)
/* Подготовим параметры дл  сальдо
/*  WRITE "PROCESS S"
  #TYPE := "S"
  UDSASH0L.SIGN := 1
  UDSASH0A.SH-OP-CL-ID := UBITMN0A.CL-ID * 10 + 4
  MOVE MBSASH0A.SA-DT-ATTR-ID TO UDSASH0A.SH-DT-ATTR-ID
  UDSASH0A.SH-DT-START := 90000000
  UDSASH0A.SH-DT-STOP  := 90000000
  /* Запускаем поиск
  MOVE "SEARCH" TO UDSASH0A.DL-COMMAND
  PERFORM UDSASH0S XXERX00A UDSASH0A
  IF RETURN-CODE NE EC-OBJECT-NOT-FOUND THEN
     IF RETURN-CODE NE 0 THEN *ERROR-NR := EC-QUIT-STACK-TRACE END-IF
     /*
     RESET #COUNT
     INCLUDE XPPBIN0C "SH-NUMBER" '"Загрузка сальдо"'
     /*
     PERFORM QUERY-PROCESS
  ELSE
     RESET XXERX00A
  END-IF
  /* Подготовим параметры дл  транзакционных операций
/*  WRITE "PROCESS T"
/* Жесткий хак, дл  обработки возвратов с участков
  IF MBSASH0A.KOR-DP-ID NE 0 THEN
     ADD 1 TO SH-AT-C
     MOVE DP-ATTR-ID TO UDSASH0A.SH-AT-ATTR-ID(SH-AT-C)
     MOVE MBSASH0A.KOR-DP-ID TO UDSASH0A.SH-AT-VALUE(SH-AT-C)
  END-IF
  #TYPE := "T"
  UDSASH0L.SIGN := 1
  UDSASH0A.SH-OP-CL-ID := UBITMN0A.CL-ID * 10 + 2
  MOVE MBSASH0A.SA-DT-ATTR-ID TO UDSASH0A.SH-DT-ATTR-ID
  UDSASH0A.SH-DT-START := 0
  UDSASH0A.SH-DT-STOP  := 90000000
  IF SA-DT NE 0 THEN
     MOVE EDITED SA-DT (EM=YYYYMMDD) TO #DATA-A
     UDSASH0A.SH-DT-STOP := #DATA-N - 1
  END-IF
  /* Запускаем поиск
  MOVE "SEARCH" TO UDSASH0A.DL-COMMAND
  PERFORM UDSASH0S XXERX00A UDSASH0A
  IF RETURN-CODE NE EC-OBJECT-NOT-FOUND THEN
     IF RETURN-CODE NE 0 THEN *ERROR-NR := EC-QUIT-STACK-TRACE END-IF
     /*
     RESET #COUNT
     INCLUDE XPPBIN0C "SH-NUMBER" '"Загрузка транзакционных операций"'
     /*
     IF MBSASH0A.KOR-DP-ID NE 0 THEN
        RESET UDSASH0A.SH-AT-G(SH-AT-C)
        SUBTRACT 1 FROM SH-AT-C
     END-IF
     PERFORM QUERY-PROCESS
  ELSE
     RESET XXERX00A
  END-IF
  IF SA-DT NE 0
     /* Подготовим параметры дл  операций
/*     WRITE "PROCESS O"
     #TYPE := "O"
     UDSASH0L.SIGN := -1
     UDSASH0A.SH-OP-CL-ID := UBITMN0A.CL-ID * 10 + 3
     MOVE MBSASH0A.SA-DT-ATTR-ID TO UDSASH0A.SH-DT-ATTR-ID
     UDSASH0A.SH-DT-START := #DATA-N
     UDSASH0A.SH-DT-STOP  := 90000000
     /* Запускаем поиск
     MOVE "SEARCH" TO UDSASH0A.DL-COMMAND
     PERFORM UDSASH0S XXERX00A UDSASH0A
     IF RETURN-CODE NE EC-OBJECT-NOT-FOUND THEN
        IF RETURN-CODE NE 0 THEN *ERROR-NR := EC-QUIT-STACK-TRACE END-IF
        /*
        RESET #COUNT
        INCLUDE XPPBIN0C "SH-NUMBER" '"Загрузка операций"'
        /*
        PERFORM QUERY-PROCESS
     ELSE
        RESET XXERX00A
     END-IF
  END-IF
  IF MBSASH0A.DR-EXCLUDE NE 0 THEN
/*     WRITE "PROCESS E"
     #TYPE := "E"
     UDSASH0L.SIGN := 1
     MOVE MBSASH0A.DR-EXCLUDE TO UDSASH0A.SH-DR-ID
     /* Запускаем поиск
     MOVE "SEARCH-DR" TO UDSASH0A.DL-COMMAND
     PERFORM UDSASH0S XXERX00A UDSASH0A
     IF RETURN-CODE NE EC-OBJECT-NOT-FOUND THEN
        IF RETURN-CODE NE 0 THEN *ERROR-NR := EC-QUIT-STACK-TRACE END-IF
        /*
        RESET #COUNT
        INCLUDE XPPBIN0C "SH-NUMBER" '"Исключение операций документа"'
        /*
        PERFORM QUERY-PROCESS
     ELSE
        RESET XXERX00A
     END-IF
  END-IF
END-SUBROUTINE
/*
DEFINE SUBROUTINE RECORD-PROCESS
/*  WRITE UR-ACC-SALDO-VIEW.MD-IT-ID(1) UR-ACC-SALDO-VIEW.MD-IT-ID(2)
/*
  MOVE UDSASH0L.SIGN TO #SIGN
/*IF *USER EQ "ARMK01" THEN
/*  WRITE *PROGRAM  #TYPE #SIGN UDSASH0A.OP-STATE UDSASH0A.TX-STATUS
/*END-IF
/*  WRITE #TYPE #SIGN UDSASH0A.OP-STATE UDSASH0A.TX-STATUS
/*        UDSASH0A.TX-CURRENT-ID UDSASH0A.OP-DR-LIST-ID(*)
  /* Если модификатор прив зан к дате, то отбираем только нужные
  IF UDSASH0A.DT-VALUE NE 0 THEN
     IF #TYPE EQ "T" AND UDSASH0A.DT-VALUE >= SA-DT THEN
        ESCAPE ROUTINE
     END-IF
     IF #TYPE EQ "O" AND UDSASH0A.DT-VALUE < SA-DT THEN
        ESCAPE ROUTINE
     END-IF
  END-IF
  /* Берем не все транзакционные записи
  IF #TYPE EQ "T" THEN
/*     WRITE 'tran' XXCTXX0A.TX-ID UDSASH0A.TX-CURRENT-ID UDSASH0A.OP-STATE  UDSASH0A.TX-STATUS
     DECIDE FOR FIRST CONDITION
     WHEN UDSASH0A.OP-STATE EQ "N" AND UDSASH0A.TX-STATUS EQ "A"
        IF XXCTXX0A.TX-ID NE UDSASH0A.TX-CURRENT-ID THEN
           ESCAPE ROUTINE
        END-IF
     WHEN UDSASH0A.OP-STATE EQ "N" AND UDSASH0A.TX-STATUS EQ "N"
        IGNORE
     WHEN UDSASH0A.OP-STATE EQ "N" AND UDSASH0A.TX-STATUS EQ "D"
        IF XXCTXX0A.TX-ID EQ UDSASH0A.TX-CURRENT-ID THEN
           ESCAPE ROUTINE
        END-IF
     WHEN UDSASH0A.OP-STATE EQ "N" AND UDSASH0A.TX-STATUS EQ "P"
        ESCAPE ROUTINE
     WHEN UDSASH0A.OP-STATE EQ "S" AND UDSASH0A.TX-STATUS EQ "P"
        #SIGN := #SIGN * -1
     WHEN UDSASH0A.OP-STATE EQ "S" AND UDSASH0A.TX-STATUS EQ "D"
        IF XXCTXX0A.TX-ID EQ UDSASH0A.TX-CURRENT-ID THEN
           #SIGN := #SIGN * -1
        ELSE
           ESCAPE ROUTINE
        END-IF
     WHEN NONE
        ESCAPE ROUTINE
     END-DECIDE
/*     WRITE 'tran accept' #SIGN
  END-IF
  /* Исключаем записи документа
  IF #TYPE EQ "E" THEN
     DECIDE FOR FIRST CONDITION
     WHEN UDSASH0A.OP-STATE EQ "N" AND UDSASH0A.TX-STATUS EQ "A"
        #SIGN := #SIGN * -1
     WHEN UDSASH0A.OP-STATE EQ "N" AND UDSASH0A.TX-STATUS EQ "N"
        #SIGN := #SIGN * -1
     WHEN UDSASH0A.OP-STATE EQ "N" AND UDSASH0A.TX-STATUS EQ "D"
        ESCAPE ROUTINE
     WHEN UDSASH0A.OP-STATE EQ "N" AND UDSASH0A.TX-STATUS EQ "P"
        ESCAPE ROUTINE
     WHEN UDSASH0A.OP-STATE EQ "P" AND UDSASH0A.TX-STATUS EQ "N"
        #SIGN := #SIGN * -1
     WHEN UDSASH0A.OP-STATE EQ "P" AND UDSASH0A.TX-STATUS EQ "P"
        ESCAPE ROUTINE
     WHEN UDSASH0A.OP-STATE EQ "S" AND UDSASH0A.TX-STATUS EQ "D"
        ESCAPE ROUTINE
     WHEN UDSASH0A.OP-STATE EQ "S" AND UDSASH0A.TX-STATUS EQ "P"
        ESCAPE ROUTINE
     WHEN NONE
        ESCAPE ROUTINE
     END-DECIDE
/*     WRITE 'excl' XXCTXX0A.TX-ID UDSASH0A.TX-CURRENT-ID UDSASH0A.OP-STATE  UDSASH0A.TX-STATUS
/*     IF MBSASH0A.DR-EXCLUDE NE 0 AND
/*        MBSASH0A.DR-EXCLUDE EQ UDSASH0A.OP-DR-LIST-ID(*) THEN
/*        ESCAPE ROUTINE
/*     END-IF
/*     WRITE 'excl accept' #SIGN
  END-IF
/*  WRITE #TYPE #SIGN UDSASH0A.OP-STATE UDSASH0A.TX-STATUS UDSASH0A.SH-OP-CL-ID UDSASH0A.IX-ID
  MOVE 5 TO MBSAST0L.STACK-FIELD-POS
  MOVE 8 TO MBSAST0L.STACK-FIELD-LEN
  CALL "CMPXF" UDSASH0A.IX-ID MBSAST0L.STACK-FIELD-POS MBSAST0L.STACK-FIELD-LEN
        STACK-NUMBER
  IF MBSAST0L.STACK-FIELD-POS EQ H'00000000' THEN
     RESET MBSAST0L.STACK-REC-G MBSAST0L.STACK-KEY-G
     MOVE UDSASH0A.IX-ID TO MBSAST0L.IX-ID
     MOVE UDSASH0A.IT-ID TO MBSAST0L.IT-ID
     MOVE UDSASH0A.IT-SALDO-TYPE TO MBSAST0L.IT-SALDO-TYPE
     FOR #I = 1 TO UDSASH0A.AT-C
        DECIDE ON FIRST VALUE UDSASH0A.AT-ATTR-ID(#I)
        VALUE DT-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.DT-ID
        VALUE MO-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.MO-ID
        VALUE DP-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.DP-ID
        VALUE GM-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.GM-ID
        VALUE PR-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.PR-ID
        VALUE MT-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.MT-ID
        VALUE MT-BASE-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.BASE-MT-ID
        VALUE DF-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.DF-ID
/*           WRITE *PROGRAM 'found df' MBSAST0L.DF-ID
        VALUE LK-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.LK-ID
        VALUE ZK-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.ZK-ID
        VALUE BS-ATTR-ID
           MOVE UDSASH0A.AT-VALUE(#I) TO MBSAST0L.BS-ID
/*           WRITE *PROGRAM 'found bs' MBSAST0L.BS-ID
        VALUE PRIH-COL-ATTR-ID
           MOVE UDSASH0A.AT-EDIZ-ID(#I) TO MBSAST0L.PRIH-EI-ID
        VALUE BASE-COL-ATTR-ID
           MOVE UDSASH0A.AT-EDIZ-ID(#I) TO MBSAST0L.BASE-EI-ID
        VALUE PLAN-COL-ATTR-ID
           MOVE UDSASH0A.AT-EDIZ-ID(#I) TO MBSAST0L.PLAN-EI-ID
        NONE VALUE
           IGNORE
        END-DECIDE
     END-FOR
/*     WRITE MBSAST0L.MT-ID MBSAST0L.BASE-MT-ID
     PERFORM SPECIAL-PUSH
  ELSE
     MOVE MBSAST0L.STACK-FIELD-POS TO MBSAST0L.STACK-POS
     CALL "RWSX" MBSAST0L.STACK-POS MBSAST0L.STACK-REC-B(1) STACK-READ  STACK-NUMBER
  END-IF
  IF UDSASH0A.SA-MODIF NE UDSASH0A.IT-SALDO-TYPE THEN
     #SIGN := #SIGN * -1
  END-IF
  FOR #I = 1 TO UDSASH0A.AT-C
     DECIDE ON FIRST VALUE UDSASH0A.AT-ATTR-ID(#I)
     VALUE PRIH-COL-ATTR-ID
        MOVE UDSASH0A.AT-VALUE(#I) TO SX-NUMBER-NUMBER
/*IF *USER EQ "ARMK01" THEN
/*  WRITE SX-NUMBER7-VALUE
/*END-IF
/*        IF MBSAST0L.PR-ID EQ 96801324 THEN
/*           WRITE #TYPE #SIGN UDSASH0A.OP-STATE  UDSASH0A.TX-STATUS
/*           MBSAST0L.PRIH-COL SX-NUMBER7-VALUE
/*           XXCTXX0A.TX-ID UDSASH0A.TX-CURRENT-ID
/*        END-IF
        MBSAST0L.PRIH-COL := MBSAST0L.PRIH-COL +
              #SIGN * SX-NUMBER7-VALUE
     VALUE BASE-COL-ATTR-ID
        MOVE UDSASH0A.AT-VALUE(#I) TO SX-NUMBER-NUMBER
/*      WRITE #SIGN MBSAST0L.BASE-COL SX-NUMBER7-VALUE
        MBSAST0L.BASE-COL := MBSAST0L.BASE-COL +
              #SIGN * SX-NUMBER7-VALUE
     VALUE PLAN-COL-ATTR-ID
        MOVE UDSASH0A.AT-VALUE(#I) TO SX-NUMBER-NUMBER
        MBSAST0L.PLAN-COL := MBSAST0L.PLAN-COL +
              #SIGN * SX-NUMBER7-VALUE
     VALUE BALC-SUM-ATTR-ID
        MOVE UDSASH0A.AT-VALUE(#I) TO SX-NUMBER-NUMBER
        MBSAST0L.BALC-SUMMA := MBSAST0L.BALC-SUMMA +
              #SIGN * SX-NUMBER2-VALUE
     NONE VALUE
        IGNORE
     END-DECIDE
  END-FOR
  IF MBSAST0L.PRIH-COL EQ 0 AND MBSAST0L.BASE-COL EQ 0 AND
     MBSAST0L.PLAN-COL EQ 0 AND MBSAST0L.BALC-SUMMA EQ 0 THEN
     IF NOT MBSAST0L.IS-FREE THEN
        MBSAST0L.IS-FREE := TRUE
        IF MBSAST0L.FREE-NEXT EQ H'00000000' THEN
        MBSAST0L.FREE-NEXT := MBSAST0A.FREE-FIRST
        MBSAST0A.FREE-FIRST := MBSAST0L.STACK-POS
     END-IF
/*     WRITE "FREE" MBSAST0L.STACK-POS
     END-IF
  ELSE
     IF MBSAST0L.IS-FREE THEN #CUR-FIRST :=TRUE
/*   WRITE "REALLOC" MBSAST0L.STACK-POS
     MBSAST0L.IS-FREE := FALSE
     END-IF
  END-IF
/*IF *USER EQ "ARMK01" /* AND MBSAST0L.BASE-MT-ID EQ 0 THEN
/*WRITE MBSAST0L.BASE-MT-ID MBSAST0L.MT-ID MBSAST0L.PLAN-COL
/*END-IF
  CALL "RWSX" MBSAST0L.STACK-POS MBSAST0L.STACK-REC-B(1) STACK-WRITE STACK-NUMBER
END-SUBROUTINE
/*
DEFINE SUBROUTINE SPECIAL-PUSH
/*IF #CUR-FIRST WRITE "PUSH" END-IF
/*  RESET #CUR-PREV
/*  #cur-first := true
  #CUR-FREE := MBSAST0A.FREE-FIRST
  REPEAT
     WHILE #CUR-FREE NE H'00000000'
     MOVE #CUR-FREE TO BUFFER.STACK-POS
     PERFORM BUFFER-READ
/*IF #CUR-FIRST WRITE #CUR-FREE BUFFER.IS-FREE BUFFER.FREE-NEXT END-IF
     IF BUFFER.IS-FREE THEN
        MOVE #CUR-FREE TO MBSAST0L.STACK-POS
        MOVE BUFFER.FREE-NEXT TO MBSAST0L.FREE-NEXT
        PERFORM STACK-WRITE
        ESCAPE ROUTINE
     ELSE
        #CUR-FREE := BUFFER.FREE-NEXT
        RESET BUFFER.FREE-NEXT
        PERFORM BUFFER-WRITE
        MBSAST0A.FREE-FIRST := #CUR-FREE
     END-IF
  END-REPEAT
/*WRITE "SIMPLE PUSH"
  PERFORM STACK-PUSH
END-SUBROUTINE
/*
INCLUDE XXSTMN4C "MBSAST0A" "MBSAST0L-CONST" "MBSAST0L"
        "STACK-INIT" "STACK-FREE" "STACK-REALLOC"
        "STACK-PUSH" "STACK-READ" "STACK-WRITE" "STACK-LOCATE"
/*
INCLUDE XXSTMN4C "MBSAST0A" "MBSAST0L-CONST" "BUFFER"
        "BUFFER-INIT" "BUFFER-FREE" "BUFFER-REALLOC"
        "BUFFER-PUSH" "BUFFER-READ" "BUFFER-WRITE" "BUFFER-LOCATE"
/*
INCLUDE XXERSY1C
END-SUBROUTINE
END
