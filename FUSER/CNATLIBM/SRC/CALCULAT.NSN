* >Natural Source Header 000000 /*<RO>>
* :NatName CALCULAT
* :UID NATM
* :Mode S
* :CP
* :Date 20020409
* :Time 1604330
* <Natural Source Header /*<<RO>
DEFINE DATA
 PARAMETER USING LCONVERT
 PARAMETER
1 GETTYPE(I4)
/* LOCAL USING RESERROR
LOCAL
1 MAXTURN(I4) CONST <50>
/*************************************
1 CYCLE(I4)
1 I(I4) /* MAIN
1 K(I4) /* INTERNAL
1 N(I4)
1 J(I4)
1 G(I4)
1 P(P22.7)
/*************************************
1 TSIZE(I4)
1 TURN(1:MAXTURN)
 2 TYPE(I1)
 2 POINT(I1)
 2 DATA(P20.7)
/*************************************
1 TSTACK
  2 NVAR(I1)
  2 DATA(P20.7/1:2)
  2 OPER(I1)
/*************************************
1 SEGMENT
 2 S(I4)
 2 E(I4)
 2 L(I4)
 2 RESULT(P20.7)
1 T(I4)
1 RRR(P16.6)
END-DEFINE
LCONVERT.ERROR := FALSE
LCONVERT.ERROR_CODE := 0
IF GETTYPE EQ 0 THRU LCONVERT.FUNCOUNT THEN IGNORE ELSE
  INCLUDE CHECKERR '15'
END-IF
DECIDE ON FIRST VALUE GETTYPE
 VALUE 1,2,3,4
  FOR T = 1 TO LCONVERT.FUNPARCOUNT(GETTYPE)
   LCONVERT.FUNPARRES(GETTYPE,T) := 0
   RESET TURN(*)
   MOVE LCONVERT.FUNVARTYPE(GETTYPE,T,1:40) TO TURN.TYPE(1:40);
   MOVE LCONVERT.FUNVARPOINT(GETTYPE,T,1:40) TO TURN.POINT(1:40);
   MOVE LCONVERT.FUNVARDATA(GETTYPE,T,1:40) TO TURN.DATA(1:40);
   PERFORM CALC_MAIN;
   IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
   COMPUTE ROUNDED LCONVERT.FUNPARRES(GETTYPE,T) = SEGMENT.RESULT;
  END-FOR
 VALUE 0
  RESET TURN(*)
  LCONVERT.RESULT := 0
  MOVE BY NAME LCONVERT.COM_TURN(1:MAXTURN)
            TO TURN(1:MAXTURN);
  PERFORM CALC_MAIN;
  IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
  COMPUTE ROUNDED LCONVERT.RESULT = SEGMENT.RESULT;
 NONE VALUE
  INCLUDE CHECKERR '15'
END-DECIDE
DEFINE SUBROUTINE CALC_MAIN
 /* œP»BECT» K HOPMAÀ‹HOM” B»ƒ”
 TSIZE := 0
 FOR I = MAXTURN TO 1 STEP -1
  IF TSIZE EQ 0 THEN
   IF TURN.TYPE(I) NE 0 THEN
    TSIZE := I;
   END-IF
  END-IF
  DECIDE ON FIRST VALUE TURN.TYPE(I)
   VALUE 51
    N := TURN.POINT(I)
    IF N EQ 1 THRU LCONVERT.VARCOUNT THEN IGNORE ELSE
     INCLUDE CHECKERR '16'
    END-IF
    SEGMENT.RESULT := LCONVERT.VARDATA(N)
   VALUE 52
    N := TURN.POINT(I)
    IF N EQ 1 THRU LCONVERT.FUNCOUNT THEN IGNORE ELSE
     INCLUDE CHECKERR '17'
    END-IF
    SEGMENT.RESULT := LCONVERT.FUNRES(N)
   ANY VALUES
    TURN.TYPE(I)  := 1
    TURN.POINT(I) := 0
    TURN.DATA(I)  := SEGMENT.RESULT
   NONE VALUE IGNORE
  END-DECIDE
 END-FOR
 /* HA…T» œAPH€E CKO¡K»
 RESET SEGMENT;
 CYCLE := 0;
 I := TSIZE
 REPEAT
  WHILE I >= 1
  ADD 1 TO CYCLE /* œPEƒOXPAH»TEÀ‹
  IF CYCLE > TSIZE*5 THEN
   INCLUDE CHECKERR '18'
  END-IF
  IF TURN.TYPE(I) EQ 12 THEN
   SEGMENT.L := 0
   SEGMENT.E := I
  END-IF
  IF TURN.TYPE(I) EQ 11 THEN
   SEGMENT.S := I
   PERFORM CALC_INTERNAL;
   IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
   PERFORM CALC_SHLOP;
   IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
   RESET SEGMENT;
   I := TSIZE
   ESCAPE TOP
  END-IF
  ADD -1 TO I
 END-REPEAT
 SEGMENT.S := 1
 SEGMENT.E := TSIZE
 SEGMENT.L := TSIZE
 PERFORM CALC_INTERNAL;
 IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
END-SUBROUTINE

DEFINE SUBROUTINE CALC_SHLOP
 ADD 1 TO SEGMENT.S
 /* O¡PA¡OTKA BCTPOEHH€X ‘”HK÷»…
 K := SEGMENT.S - 2
 IF K > 0 THEN
  DECIDE ON FIRST VALUE TURN.TYPE(K)
   VALUE 31 /* ABS
    SEGMENT.RESULT := ABS(SEGMENT.RESULT)
   ANY VALUES
    ADD -1 TO SEGMENT.S
   NONE VALUE IGNORE
  END-DECIDE
 END-IF
 N := SEGMENT.E
 FOR K = SEGMENT.S TO TSIZE
  ADD 1 TO N
  IF N > TSIZE THEN ESCAPE BOTTOM END-IF
  MOVE BY NAME TURN(N) TO TURN(K)
 END-FOR
 RESET TURN(K:MAXTURN);
 ADD -1 TO SEGMENT.S
 K := SEGMENT.S
 RESET TURN(K)
 TURN.TYPE(K)  := 1
 TURN.POINT(K) := 0
 TURN.DATA(K)  := SEGMENT.RESULT
END-SUBROUTINE
DEFINE SUBROUTINE CALC_INTERNAL /* O¡PA¡OTKA HOPMAÀ‹HO… ‘OPM€
 RESET TSTACK;
 FOR K = SEGMENT.S TO SEGMENT.E
  DECIDE ON FIRST VALUE TURN.TYPE(K) /* ‘»À‹TP
   VALUE 26   /* '^'
    IF K > 1 AND K < MAXTURN THEN
      PERFORM CALC_CENTER ;
      IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
     ELSE
      INCLUDE CHECKERR '19'
    END-IF
   ANY VALUES
    IF TSTACK.NVAR EQ 2 AND TSTACK.OPER NE 0 THEN
     PERFORM CALC_OPER
     IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
    END-IF
   NONE VALUE IGNORE
  END-DECIDE
 END-FOR
 FOR K = SEGMENT.S TO SEGMENT.E
  DECIDE ON FIRST VALUE TURN.TYPE(K) /* ‘»À‹TP
   VALUE 23,24,25
    IF K > 1 AND K < MAXTURN THEN
      PERFORM CALC_CENTER ;
      IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
     ELSE
      INCLUDE CHECKERR '19'
    END-IF
   ANY VALUES
    IF TSTACK.NVAR EQ 2 AND TSTACK.OPER NE 0 THEN
     PERFORM CALC_OPER
     IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
    END-IF
   NONE VALUE IGNORE
  END-DECIDE
 END-FOR
 FOR K = SEGMENT.S TO SEGMENT.E
  DECIDE ON FIRST VALUE TURN.TYPE(K) /* ‘»À‹TP
   VALUE 21,22
    IF K >= 1 AND K < MAXTURN THEN
      PERFORM CALC_CENTER ;
      IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
     ELSE
      INCLUDE CHECKERR '19'
    END-IF
   ANY VALUES
    IF TSTACK.NVAR EQ 2 AND TSTACK.OPER NE 0 THEN
     PERFORM CALC_OPER
     IF LCONVERT.ERROR THEN ESCAPE ROUTINE END-IF
    END-IF
   NONE VALUE IGNORE
  END-DECIDE
 END-FOR
 FOR K = SEGMENT.S TO SEGMENT.E
  DECIDE ON FIRST VALUE TURN.TYPE(K) /* ‘»À‹TP
   VALUE 1
    TSTACK.DATA(1) := TURN.DATA(K)
   NONE VALUE IGNORE
  END-DECIDE
 END-FOR
SEGMENT.RESULT := TSTACK.DATA(1)
RESET TSTACK;
END-SUBROUTINE
DEFINE SUBROUTINE CALC_CENTER /* O¡PA¡OTKA OœEPA÷»…
 RESET TSTACK;
 N := K - 1
 G := 0
 FOR J = N TO SEGMENT.S STEP -1
  IF TURN.TYPE(J) EQ 1 THEN G := J ESCAPE BOTTOM END-IF
 END-FOR
 IF G EQ 0 AND (TURN.TYPE(K) NE 22 AND TURN.TYPE(K) NE 21)THEN
  INCLUDE CHECKERR '20'
 END-IF
 IF G > 0 THEN
  TSTACK.DATA(1) := TURN.DATA(G)
  RESET TURN(G)
          END-IF
 ADD 1 TO TSTACK.NVAR
 N := K + 1
 FOR J = N TO SEGMENT.E
  IF TURN.TYPE(J) EQ 1 THEN G := J ESCAPE BOTTOM END-IF
 END-FOR
 IF G EQ 0 THEN
  INCLUDE CHECKERR '20'
 END-IF
 TSTACK.DATA(2) := TURN.DATA(G)
 ADD 1 TO TSTACK.NVAR
 RESET TURN(G)
 TSTACK.OPER := TURN.TYPE(K)
END-SUBROUTINE
DEFINE SUBROUTINE CALC_OPER /* O¡PA¡OTKA OœEPA÷»…
 DECIDE ON FIRST VALUE TSTACK.OPER /* O¡PA¡OTKA OœEPA÷»…
  VALUE 21
   TSTACK.DATA(1) := TSTACK.DATA(1) + TSTACK.DATA(2)
  VALUE 22
   TSTACK.DATA(1) := TSTACK.DATA(1) - TSTACK.DATA(2)
  VALUE 23
   TSTACK.DATA(1) := TSTACK.DATA(1) * TSTACK.DATA(2)
  VALUE 24
  RRR := TSTACK.DATA(1)
  TSTACK.DATA(1) := RRR / TSTACK.DATA(2)
  VALUE 25
   RRR := TSTACK.DATA(1)
   TSTACK.DATA(1) := RRR / TSTACK.DATA(2)
   TSTACK.DATA(1) := INT(TSTACK.DATA(1))
  ANY VALUES
   TSTACK.NVAR    := 1
   TSTACK.OPER    := 0
   TSTACK.DATA(2) := 0
   RESET TURN(K)
   TURN.TYPE(K)  := 1
   TURN.POINT(K) := 0
   TURN.DATA(K)  := TSTACK.DATA(1)
  NONE VALUE
   INCLUDE CHECKERR '21'
 END-DECIDE
END-SUBROUTINE
ON ERROR
 INCLUDE CHECKERR '22'
 ESCAPE ROUTINE
END-ERROR
END
