* >Natural Source Header 000000 /*<RO>>
* :NatName READMY
* :UID TIT_HOME
* :Mode S
* :CP
* :Date 19990120
* :Time 0311330
* <Natural Source Header /*<<RO>
*********************************************************
Комплекс состоит из 2 подпрограмм, перва  из которых
разбирает входную строку и представл ет ес лексические
единицы в сгруппированном виде.
Втора  осуществл ет вычисление.

Возможности:
 1) Строка заполн етс  в обычном арифметическом стиле
 2) В выражении могут присутствовать переменные
 3) Доступны скобки любого уровн  вложенности
 4) Доступны операторы:
     '+','-','*','/'
     '%' - делить нацело
     '^' - возвести в степень /не работает/
 5) Доступны встроенные функции
    (на текущий момент)
    'ABS' - абсолютное значение
 6) В выражении возможно использование числовых констант
    (дес тична  часть отдел етьс  точкой)
 7) В выражении могут присутствовать функции пользовател
 8) Если им  функции и им  переменной совпадают, то за значение
 переменной принимаетс  значение функции.
   FUN(STAT1,SUMMA,STAT2+STAT3)+(FUN-125)%2 - переменна  FUN есть
                                              значение функции FUN
   FUN(125+FUN/2) - значением переменной FUN будет 0
 9) Параметры функций могут быть представлены в виде
    выражени  со скобками и содержащего другую функцию
    (параметры функций раздел ютс  зап тыми и заключены в скобки)
Налагаемые ограничени :
 1) Соответствие списка переменных в строке CMD и списка переменных,
 доступных в конкретной системе возлагаетс  на внешнюю программу.
 2) Соответствие списка пользовательских функций и списка
 функций, доступных в конкретной системе возлагаетс  на внешнюю
 программу.
 3) Проверка корректности количества параметров пользовательских
 функций возлагаетс  на внешнюю программу.
 4) Количество лексем в выражении не может быть больше 50
     5 + 4                          -> 3 лексемы
     (5+4)+2                        -> 7
     5 + 4/2                        -> 5
     X1 + 2 + X4%2                  -> 7
     ((5+1) -10)*X1                 -> 11
     funct(X1,X2+X3,4)              -> 1
     128 + funct(12,(X1+3)/2,X4)/2  -> 5
 5) В строке может присутствовать не более 5 пользовательских функций
    (два вызова одной функции принимаетс  за 2 функции, в этом
     случае указатель на функцию ссылаетс  на ес первый экземпл р)
 6) Функци  может иметь не более 4 параметров
 7) Количество лексем в выражении,  вл ющемс  параметром функции,
 должно быть не больше 40
 8) Общее количество переменных не более 20
 9) В выражении не могут содержатьс  буквы не английского алфавита
10) Константы в строке выражени  и результаты вычислений должны помещатьс
 в формат (P15.6), промежуточные вычислени  провод тьс  в формате (P20.7)
 Результаты инициализируютс  присвоением с округлением.
11) Функции пользовател  наход тьс  в списке LCONVERT.FUNCTION(*) в пор дке,
 обратном тому, в котором они встречаютс  в выражении.
12) Такие ошибки, как деление на нуль, возведение в дробную степень и т.д.
 определ ютс  только на этапе вычислени , при вызове функции "CALCULAT".
 Возможнисть их возникновени  не определ етс  на этапе трансл ции
 в функции "CHECKCMD"
*********************************************************
Описание параметрической области "LCONVERT":
   1 LCONVERT
>   2 CMD(A70) /* Входной параметер
     /* Если входной параметер не корректен, или возникла ошибка в работе
     /* подпрограммы, то LCONVERT.ERROR eq TRUE
     /* в LCONVERT.ERROR_CODE возвращаетс  код ошибки. Коду ошибки соответствует
     /* строка RESERROR(ERROR_CODE) в локальной области "RESERROR"
=   2 ERROR(L) /* ФЛАГ ОШИБКИ
=   2 ERROR_CODE(I4) /* КОД ОШИБКИ
     /* Дальнейшие пол  инициализируютс  вызовом подпрограммы 'CHECKCMD'
=   2 VARCOUNT(I1) /* Количество уникальных переменных, найденных в строке CMD
    2 VARIABLE(1:20)
=     3 VARNAME(A10) /* список имен переменных, каждое им  уникально, даже если
                     /* переменна  несколько раз входит в выражение
>     3 VARDATA(P15.6) /* Значение соответствующей переменной. Инициализируетс
                       /* пользователем
=   2 FUNCOUNT(I1) /* Количество найденных функций
    2 FUNCTION(1:5)
=     3 FUNNAME(A10)    /* Список имен функций
=     3 FUNPARCOUNT(I1) /* Количество параметров каждой функции
      3 FUNPARAMETER(1:4)
=       4 FUNPVARCOUNT(I1) /* Количество уникальных переменных, вход щих в
                           /* выражение, которое  вл етс  параметром функции
=       4 FUNPVAR(I1/1:20) /* Список переменных, каждое поле есть индекс в
                           /* массиве LCONVERT.VARNAME
        4 FUNTURN(1:40) /* Описание выражени  в каждом параметре,
                        /* эту структуру трогать нельз
          5 FUNVARTYPE(I1) /* SYSTEM, NOT CHANGE
          5 FUNVARPOINT(I1) /* SYSTEM, NOT CHANGE
          5 FUNVARDATA(P15.6) /* SYSTEM, NOT CHANGE
=       4 FUNPARRES(P15.6) /* Значение параметра функции, вычисл етс  при вызове
                           /* подпрограммы "CALCULAT" на основании заполненной
                           /* пользователем таблицы LCONVERT.VARDATA и
                           /* системной таблицы LCONVERT.FUNTURN
>     3 FUNRES(P15.6) /* Значение функции. Должно быть инициализировано
                      /* пользователем, если функци  пользовател  возвращает
                      /* одно число, и принимает участие в другом выражении
                      /* MYFUN(VAR1+10)%2
=   2 RESULT(P15.6) /* Результат выражени  в CMD,вычисл етс  при вызове
                    /* подпрограммы "CALCULAT"
    2 COM_TURN(1:50)/* Описание выражени  в строке CMD,
                    /* эту структуру трогать нельз
      3 TYPE(I1) /* SYSTEM, NOT CHANGE
      3 POINT(I1) /* SYSTEM, NOT CHANGE
      3 DATA(P15.6) /* SYSTEM, NOT CHANGE
----------------------
 P.S.
 > Поле инициализируетс  пользователем
 = Поле инициализируетс  подпрограммой, служит дл  контрол  строки CMD
----------------------
*********************************************************

Примерна  последовательность обработки входной строки:

1) RESET LCONVERT ;
   LCONVERT.CMD := INPUT_COMMAND_STRING ;
   CALLNAT 'CHECKCMD' LCONVERT ; /* Проверка входной строки
                                 /* Разложение строки на составл ющие
2) /* Проверка предыдущего вызова 'CHECKCMD' на наличие ошибки
   /* может проходить по следующей схеме :
   /* (описание кодов ошибок в "RESERROR")
   IF LCONVERT.ERROR THEN
    IF LCONVERT.ERROR_CODE EQ 1 THRU NRESERROR THEN
      WRITE 'Ошибка с кодом :' LCONVERT.ERROR_CODE /
           'Текст :' RESERROR(ERROR_CODE)
     ELSE
      WRITE 'Ошибка с кодом :' LCONVERT.ERROR_CODE
    END-IF
   END-IF
3) /* Инициализаци  переменных в соответствии со списком
   /* в LCONVERT.VARIABLE(1:LCONVERT.VARCOUNT)
   /* Каждой переменной в поле LCONVERT.VARNAME(v)
   /* с индексом от 1 до LCONVERT.VARCOUNT нужно сопоставить
   /* ес значение в поле LCONVERT.VARDATA(v)
   /* мен ть пол  LCONVERT.VARCOUNT и LCONVERT.VARNAME нельз .
   .
   .
   .
4) /* Вычисление параметров пользовательских функций
   /* Количество найденных функций в поле LCONVERT.FUNCOUNT
   /* Каждой функции соответсвует структура LCONVERT.FUNCTION(*)
   /* Количество параметров в поле LCONVERT.FUNPARCOUNT(f)
   /* Каждому параметру соответствует структура LCONVERT.FUNPARAMETER(f,*)
   /* Список переменных, участвующих в определении p-ого параметра
   /* f-ой функции в поле LCONVERT.FUNPVAR(f,p,*)
   /* Этот список содержит индексы переменных в структуре LCONVERT.VARIABLE
   /* Дл  вычислени  значени  параметров f-ой функции надо вызвать
   /* подпрограмму :
    FOR I(I1) = 1 TO LCONVERT.FUNCOUNT
     CALLNAT 'CALCULAT' I LCONVERT ;
     .
     . /* check for error
     .
    END-FOR
   /* значени  вычисленных параметров будут лежать в пол х
   /*    LCONVERT.FUNPARRES(f,p)
5) /* Проверка предыдущего вызова 'CALCULAT' на наличие ошибки
   /* может проходить по следующей схеме :
   IF LCONVERT.ERROR THEN
    IF LCONVERT.ERROR_CODE EQ 1 THRU NRESERROR THEN
      WRITE 'Ошибка с кодом :' LCONVERT.ERROR_CODE /
           'Текст :' RESERROR(ERROR_CODE)
     ELSE
      WRITE 'Ошибка с кодом :' LCONVERT.ERROR_CODE
    END-IF
   END-IF
6) /* После этого можно вызвать программу или функцию, вычисл ющюю значение
   /* пользовательской функции или выполн ющюю специфические вычислени
   /* Дл  реаизации этого желательно пользоватьс  програмным модуем типа
   /* "Subroutine"
   /* Если предполагаютс  дальнейшие вычислени , то-есть пользовательские функции
   /* вход т в состав более общего выражени , то значение f-ой функции должно быть
   /* присвоено полю LCONVERT.FUNRES(f)
   /* вызов программ, соответствующих пользовательским функци м, может быть
   /* произведен в следующем виде:
    FOR I(I1) = 1 TO LCONVERT.FUNCOUNT
     DECIDE ON FIRST VALUE LCONVERT.FUNNAME(I)
      VALUE 'My_fun_1'
       PERFORM myfun1 LCONVERT.FUNRES(I)
                      LCONVERT.FUNPARRES(I,1)
                      LCONVERT.FUNPARRES(I,2);
      VALUE 'My_fun_2'
       PERFORM My_fun_2 LCONVERT.FUNRES(I)
                        LCONVERT.FUNPARRES(I,1) ;
      VALUE 'DIST'
       N_STAT(I1) := LCONVERT.FUNPVARCOUNT(I,3)
       PERFORM SDISTRIB LCONVERT.FUNPVAR(I,1,1)
                        LCONVERT.FUNPARRES(I,2)
                        LCONVERT.FUNPARRES(I,3)
                        N_STAT
                        LCONVERT.FUNPVAR(I,3,1:N_STAT);
      NONE VALUE STOP /* присутствует неопределенна  функци
     END-DECIDE
    END-FOR
   /* Кроме значени  пол  LCONVERT.FUNRES(f) мен ть значени  полей в
   /* структуре LCONVERT.FUNCTION нельз .
   /* Также надо учитывать, что при передаче параметров количество размерностей
   /* массивов данных должна совпадать у вызывающего модул  и вызываемого
   /*  1) вызов : PERFORM FUN VAR(1:40) ; в функции : VAR(A10/1:V)
   /*  2) вызов : PERFORM FUN VAR(1:40,1:10) ; в функции : VAR(A10/1:V,1:V)
   /*  3) вызов : PERFORM FUN VAR(1,1:10) ; в функции : VAR(A10/1:V)  <=== неправильно
   /* Чтобы обойти это и гарантировать сохранение значений в структуре LCONVERT,
   /* желательно дл  модулей, которые вызываютс  при вычислении пользовательских
   /* функций, определить параметрические области, и перед вызовом своего модул
   /* производить переприсвоение необходимых значений из структуры LCONVERT в
   /* собственную параметрическую область.
7) /* Окончательные вычислени  выполн ютс  с помощью вызова
   /* подпрограммы 'CALCULAT' с нулевым индексом.
   /* результат возвращаетьс  в поле LCONVERT.FUNRES
    CALLNAT 'CALCULAT' 0 LCONVERT ;
5) /* Проверка предыдущего вызова 'CALCULAT' на наличие ошибки
   /* может проходить по следующей схеме :
   IF LCONVERT.ERROR THEN
    IF LCONVERT.ERROR_CODE EQ 1 THRU NRESERROR THEN
      WRITE 'Ошибка с кодом :' LCONVERT.ERROR_CODE /
           'Текст :' RESERROR(ERROR_CODE)
     ELSE
      WRITE 'Ошибка с кодом :' LCONVERT.ERROR_CODE
    END-IF
   END-IF
*********************************************************
 Пример строки выражени :
X1+((X2 +X3- 4.53)%2+ ABS(X1-X2)) + FUNUSER(X5,3,(X1+X2))/0.5
------------------------------------------------------
Разложение в "LCONVERT" после вызова "CHECKCMD"
------------------------------------------------------
Переменные:
VARCOUNT - 4
VARIABLE
  VARNAME   1 - X1
            2 - X2
            3 - X3
            4 - X5
  VARDATA - ???
Функции :
 FUNCOUNT - 1
 FUNCTION
   FUNNAME   1 - FUNUSER
   FUNPARCOUNT - 3
   FUNPARAMETER
      FUNPVAR 1 - 4
              2 - 0
              3 - 1,2
      FUNTURN 1 - (51,4,)
              2 - (1,,3)
              3 - (51,1,);(51,2,);(21,,)
   FUNRES - ???



Строка дл  вычислител : COM_TURN
=========================================================
ТИП ПОЛЯ : 1
ДОСТУПНЫЕ ОПЕРАТОРЫ :
  Code                        Point             Data
  ------------         |  -------------  |  -------------
    1  - constant      |        0        |        ?
   11  - '('           |        0        |        0
   12  - ')'           |        0        |        0
   21  - '+'           |        0        |        0
   22  - '-'           |        0        |        0
   23  - '*'           |        0        |        0
   24  - '/'           |        0        |        0
   25  - '%'           |        0        |        0
   26  - '^'           |        0        |        0      /не работает/
   31  - 'ABS'         |        0        |        0
   51  - User variable |  Index VARDATA  |        0
   52  - User function |  Index FUNRES   |        0
=========================================================

     51,1,0
     51,2,0
     51,3,0
     21,0,0
      1,0,4.53
     22,0,0
      1,0,2
     25,0,0
     51,1,0
     51,2,0
     22,0,0
     31,0,0
     21,0,0
     21,0,0
     52,1,0
      1,0,0.5
     24,0,0
     21,0,0

*********************************************************
